---
title: "Final Takehome Movie Data"
author: "Xinwei Huang"
date: "2018 0501"
output: html_document
---

---
title: "Midterm"
author: "Xinwei Huang"
output:
  html_document:
    df_print: paged
---

```{r,echo = FALSE,message=FALSE}
library(ggplot2,warn.conflicts = FALSE)
library(dplyr,warn.conflicts = FALSE)
library(tidyr,warn.conflicts = FALSE)
library(readr,warn.conflicts = FALSE)
library(gridExtra,warn.conflicts = FALSE)
library(GGally,warn.conflicts = FALSE) 
library(leaps,warn.conflicts = FALSE) 
library(glmnet,warn.conflicts = FALSE)
library(purrr,warn.conflicts = FALSE)
library(jsonlite,warn.conflicts = FALSE)
library(curl,warn.conflicts = FALSE)
```

### Part I: Introduction

```{r}
tmdb <- read_csv("https://www.dropbox.com/s/sesaejgna9fkg1q/tmdb_5000.csv?dl=1")
```

```{r}
#Returns the first two characters listed in the credits in their own columns. 
#There is a unique row for each movie ID with at least one character.

chars <-
  tmdb %>% 
  select(id, cast) %>% 
  filter(nchar(cast)>2) %>% 
  mutate(js=map(cast,fromJSON)) %>% 
  unnest(js, .drop = FALSE) %>% 
  group_by(id) %>% 
  summarize(char1 = first(character),
            char2 = nth(character, n=2))

#Returns the first two genres reported in their own columns. 
#There is a unique row for each movie ID with at least one genre.

genres <-
  tmdb %>% 
  select(id, genres) %>% 
  filter(nchar(genres)>2) %>% 
  mutate(js = map(genres,fromJSON)) %>% 
  unnest(js, .drop = FALSE) %>% 
  group_by(id) %>% 
  summarize(genre1 = first(name),
            genre2 = nth(name, n=2))

#Returns the first two key words reported in their own columns. 
#There is a unique row for each movie ID with at least one keyword.

keywords <-
  tmdb %>% 
  select(id, keywords) %>% 
  filter(nchar(keywords)>2) %>% 
  mutate(js = map(keywords,fromJSON)) %>% 
  unnest(js, .drop = FALSE) %>% 
  group_by(id) %>% 
  summarize(keyword1 = first(name),
            keyword2 = nth(name, n=2))


#Returns the first production company. 
#There is a unique row for each movie ID with at least one production company

production_company <-
  tmdb %>% 
  select(id, production_companies) %>% 
  filter(nchar(production_companies)>2) %>% 
  mutate(js = map(production_companies,fromJSON)) %>% 
  unnest(js, .drop = FALSE) %>% 
  group_by(id) %>% 
  summarize(prod_comp_main = first(name))

#Returns the first production country. 
#There is a unique row for each movie ID with at least one production country

production_country <-
  tmdb %>% 
  select(id, production_countries) %>% 
  filter(nchar(production_countries)>2) %>% 
  mutate(js = map(production_countries,fromJSON)) %>% 
  unnest(js, .drop = FALSE) %>% 
  group_by(id) %>% 
  summarize(country_main = first(iso_3166_1))

#Combine the tables created above with the original data and drops some of the columns.

tmdb_enhanced <-
  tmdb %>% 
  select(-genres, -keywords, -production_companies, -production_countries,
         -spoken_languages, -cast, -crew) %>% 
  left_join(chars, 
            by = "id") %>% 
  left_join(genres, 
            by = "id") %>% 
  left_join(keywords, 
            by = "id") %>% 
  left_join(production_country,
            by = "id") %>% 
  left_join(production_company, 
            by = "id")

```

```{r}
summary(tmdb_enhanced)
```

First, we summarize the data and look for the question to answer. The whole dataset has 6 quantitative variables and 17 categorical variables, and among them, revenue is a good dependent variable because it is a good measure of successful movie. So, we want to build a best model to predict the revenue of a movie, based on the data we have. 


### Part II: Exploring Data

In order to find some good categorical variables to use, we made tables for each of reasonable categorical variables. As the result, some of them are not suitbale to be include in the model. For example, the keyword variable has too many categories and each category has few observations. Because the table is too long, we don't show it below. For the similar reason, we decide not to use the charactors variable and production company variable. For the genres variable, there are two genres variables, which are shown below. We can see that genre1 variable is good to use because its observations are seperated into each vategories. However, genre2 variable has 928 NAs in it, which means it is not a good option for independent variable. The last categorical variable we explored is the country variable. As shown in Table 3, most of the movies are actually made in U.S., and many other countries only have 1 movie in its category, so, we decide to not use it in our model. Other categorical variables like website, title, overview etc. are not actually influencing the revenue made, so we just ignore them. 

```{r,echo = FALSE}
library(knitr)
kable(
  tmdb_enhanced %>% 
    group_by(genre1) %>% 
    count(),
  align = c("l", "c"),
  caption = "Table 1: Distribution of genre1"
)
```

```{r,echo = FALSE}
library(knitr)
kable(
  tmdb_enhanced %>% 
    group_by(genre2) %>% 
    count(),
  align = c("l", "c"),
  caption = "Table 2: Distribution of genre2"
)
```

```{r,echo = FALSE}
library(knitr)
kable(
  tmdb_enhanced %>% 
    group_by(country_main) %>% 
    count(),
  align = c("l", "c"),
  caption = "Table 3: Distribution of countries of production"
)
```

Because we exclude all other categorical variables except the genre1, we made a new dataset that with no N/A in it.  

```{r}
tmdb_mod <-
  tmdb_enhanced %>%
  select(revenue, budget, popularity, runtime, vote_average, vote_count, genre1,genre2,country_main) %>%
  drop_na()
```

Next, we analyzes the relationship between quantitative variables and our dependent variable revenue. By reasoning, we can see that all 5 quantitative variables other than revenue tend to influence the revenue of a movie. A higher popularity and vote count means there are more people have seen this movie, which creates more revenue. A higher vote score means the movie is better so that more people are going to watch the movie and thus increases the revenue. A higher budget tends to make a better special effects in the movie and thus make it more attractive. And longer runtime means the movie has longer time to tell the whole story, which may make it more attractive for the audience. So, all 5 quantitative variabels are good to be used as independent variables. We plot the relationship between each of those 5 and the revenue variable by establishing simple linear regressions. 

```{r,message=FALSE}
budgetmod <- lm(tmdb_mod$revenue ~ tmdb_mod$budget)
budgetr <- tmdb_mod %>% 
  ggplot(aes(x=budget, y=revenue)) +
  geom_point(color="red") +
  geom_abline(intercept = -4.201e+06, slope = 2.978e+00, size = 1)


popularitymod <- lm(tmdb_mod$revenue ~ tmdb_mod$popularity)
popularityr <- tmdb_mod %>% 
  ggplot(aes(x=popularity, y=revenue)) +
  geom_point(color="red") +
  geom_abline(intercept = 16080789, slope = 3286249, size = 1)



votecountmod <- lm(tmdb_mod$revenue ~ tmdb_mod$vote_count)
votecountr <- tmdb_mod %>% 
  ggplot(aes(x=vote_count, y=revenue)) +
  geom_point(color="red") +
  geom_abline(intercept = 12559961, slope = 103998, size = 1)


voteaveragemod <- lm(tmdb_mod$revenue ~ tmdb_mod$vote_average)
voteaverager <- tmdb_mod %>% 
  ggplot(aes(x=vote_average, y=revenue)) +
  geom_point(color="red") +
  geom_abline(intercept = -135831453, slope = 37230135, size = 1)


runtimemod <- lm(tmdb_mod$revenue ~ tmdb_mod$runtime)
runtimer <- tmdb_mod %>% 
  ggplot(aes(x=runtime, y=revenue)) +
  geom_point(color="red") +
  geom_abline(intercept =  -141811217, slope = 2180476, size = 1)


grid.arrange(budgetr,popularityr,runtimer,voteaverager,votecountr, ncol=3)
```

We can see from those plots that budget variable and vote_count variable have good linear relationship with revenue. The rest three variables don't have obvious linear relationship with revenue, but the simple model regressions shows that they are statistically significant in interpreting the revenue. So, we are going to use all of those 5 variables as independent variables. 

### Part III: Checking Model Assumptions
After exploring the data, we want to biuld up a model including all variables we found suitable to predict revenue, and check model assumptions to decide if we want to transform the data. 

```{r}
basicmod <- lm(revenue ~ budget + popularity + runtime + vote_average + vote_count + genre1,data = tmdb_mod)
summary(basicmod)
```
From the model, we see that the p-value for 5 quantitative variables are all smaller than 0.05. But for some genre categories, the p-value is larger than 0.05, like Music and Mystery genre. Next, we plot the residual vs. fitted value plot to check the model assumptions. 



```{r}
tmdb_mod %>% 
  mutate(fitted.vals = basicmod$fitted.values, 
         resids = basicmod$residuals) %>% 
  ggplot(aes(x=fitted.vals, y=resids)) +
  geom_jitter(width = 5) +
  geom_hline(yintercept = 0, color="gray") +
  geom_smooth(se = FALSE)
```

We see that the residuals are clustered at left, and the mean error is increasing as fitted values increases. So, we try to use the log value of revenue. 

```{r}
logrevenue <- log(tmdb_mod$revenue)
tmdb_mod$logrevenue <- logrevenue
summary(tmdb_mod$logrevenue)
```

We see that because there are 0s in the revenue variable, the min value of logrevenue is -Infinite. So, we decide to delete all observations that has 0 revenue, because in reality, it is impossible to have 0 revenue and those observations will influence our model. 

```{r}
tmdb_mod1 <-
  tmdb_mod %>% filter(budget!=0, revenue!=0)
```

```{r}
basicmod1 <- lm(revenue ~ budget + popularity + runtime + vote_average + vote_count + genre1,data = tmdb_mod1)
summary(basicmod)
```
